# ===== ÏΩîÎû©Ïö© ÏôÑÏ†ÑÌïú ÎùºÏù¥Ïóá API ÎÇ¥Ï†Ñ Í¥ÄÎ¶¨ ÏãúÏä§ÌÖú =====
# Ïù¥ ÌååÏùºÏùÑ ÏΩîÎû©ÏóêÏÑú Ïã§ÌñâÌïòÏÑ∏Ïöî!

# 1. ÌïÑÏöîÌïú ÎùºÏù¥Î∏åÎü¨Î¶¨ ÏÑ§Ïπò
!pip install requests pandas matplotlib seaborn plotly streamlit

# 2. ÎùºÏù¥Î∏åÎü¨Î¶¨ import
import requests
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import json
import time
from datetime import datetime, timedelta
import streamlit as st
from typing import Dict, List, Optional
import warnings
warnings.filterwarnings('ignore')

# 3. ÌïúÍ∏Ä Ìè∞Ìä∏ ÏÑ§Ï†ï
plt.rcParams['font.family'] = 'DejaVu Sans'
plt.rcParams['axes.unicode_minus'] = False

print("‚úÖ ÎùºÏù¥Î∏åÎü¨Î¶¨ ÏÑ§Ïπò Î∞è import ÏôÑÎ£å!")

# ===== ÎùºÏù¥Ïóá API ÌÅ¥ÎûòÏä§ =====

class RiotAPIManager:
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.base_urls = {
            'asia': 'https://asia.api.riotgames.com',
            'kr': 'https://kr.api.riotgames.com'
        }
        self.rate_limits = {
            'personal': {'limit': 100, 'window': 120},
            'app': {'limit': 20000, 'window': 600}
        }
        
        # Ï±îÌîºÏñ∏ Îç∞Ïù¥ÌÑ∞
        self.champions = {
            1: {'name': 'Í∞ÄÎ†å', 'image': 'https://ddragon.leagueoflegends.com/cdn/13.24.1/img/champion/Garen.png'},
            2: {'name': 'ÏïÑÎ¶¨', 'image': 'https://ddragon.leagueoflegends.com/cdn/13.24.1/img/champion/Ahri.png'},
            3: {'name': 'ÏïºÏä§Ïò§', 'image': 'https://ddragon.leagueoflegends.com/cdn/13.24.1/img/champion/Yasuo.png'},
            4: {'name': 'ÏßÑ', 'image': 'https://ddragon.leagueoflegends.com/cdn/13.24.1/img/champion/Jhin.png'},
            5: {'name': 'Îü≠Ïä§', 'image': 'https://ddragon.leagueoflegends.com/cdn/13.24.1/img/champion/Lux.png'},
            6: {'name': 'Îã§Î¶¨Ïö∞Ïä§', 'image': 'https://ddragon.leagueoflegends.com/cdn/13.24.1/img/champion/Darius.png'},
            7: {'name': 'Ïπ¥ÌÉÄÎ¶¨ÎÇò', 'image': 'https://ddragon.leagueoflegends.com/cdn/13.24.1/img/champion/Katarina.png'},
            8: {'name': 'Ïù¥Ï¶àÎ¶¨Ïñº', 'image': 'https://ddragon.leagueoflegends.com/cdn/13.24.1/img/champion/Ezreal.png'},
            9: {'name': 'ÏÜåÎÇò', 'image': 'https://ddragon.leagueoflegends.com/cdn/13.24.1/img/champion/Sona.png'},
            10: {'name': 'Î¶¨Ïã†', 'image': 'https://ddragon.leagueoflegends.com/cdn/13.24.1/img/champion/LeeSin.png'}
        }
    
    def get_summoner_by_riot_id(self, game_name: str, tag_line: str) -> Optional[Dict]:
        """ÎùºÏù¥Ïóá IDÎ°ú ÏÜåÌôòÏÇ¨ Ï†ïÎ≥¥ Ï°∞Ìöå"""
        url = f"{self.base_urls['asia']}/riot/account/v1/accounts/by-riot-id/{game_name}/{tag_line}"
        headers = {'X-Riot-Token': self.api_key}
        
        try:
            response = requests.get(url, headers=headers, timeout=10)
            if response.status_code == 200:
                return response.json()
            elif response.status_code == 404:
                print(f"‚ùå ÌîåÎ†àÏù¥Ïñ¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: {game_name}#{tag_line}")
                return None
            else:
                print(f"‚ùå API Ìò∏Ï∂ú Ïã§Ìå®: {response.status_code}")
                return None
        except Exception as e:
            print(f"‚ùå ÏÜåÌôòÏÇ¨ Ï†ïÎ≥¥ Ï°∞Ìöå Ïã§Ìå®: {e}")
            return None
    
    def get_summoner_by_puuid(self, puuid: str) -> Optional[Dict]:
        """PUUIDÎ°ú ÏÜåÌôòÏÇ¨ ÏÉÅÏÑ∏ Ï†ïÎ≥¥ Ï°∞Ìöå"""
        url = f"{self.base_urls['kr']}/lol/summoner/v4/summoners/by-puuid/{puuid}"
        headers = {'X-Riot-Token': self.api_key}
        
        try:
            response = requests.get(url, headers=headers, timeout=10)
            if response.status_code == 200:
                return response.json()
            else:
                print(f"‚ùå ÏÜåÌôòÏÇ¨ ÏÉÅÏÑ∏ Ï†ïÎ≥¥ Ï°∞Ìöå Ïã§Ìå®: {response.status_code}")
                return None
        except Exception as e:
            print(f"‚ùå ÏÜåÌôòÏÇ¨ ÏÉÅÏÑ∏ Ï†ïÎ≥¥ Ï°∞Ìöå Ïã§Ìå®: {e}")
            return None
    
    def get_league_entries(self, summoner_id: str) -> List[Dict]:
        """ÏÜåÌôòÏÇ¨ Î¶¨Í∑∏ Ï†ïÎ≥¥ Ï°∞Ìöå (ÏÜîÎ°úÎû≠ÌÅ¨Îßå)"""
        url = f"{self.base_urls['kr']}/lol/league/v4/entries/by-summoner/{summoner_id}"
        headers = {'X-Riot-Token': self.api_key}
        
        try:
            response = requests.get(url, headers=headers, timeout=10)
            if response.status_code == 200:
                data = response.json()
                return [entry for entry in data if entry.get('queueType') == 'RANKED_SOLO_5x5']
            else:
                return []
        except Exception as e:
            print(f"‚ùå Î¶¨Í∑∏ Ï†ïÎ≥¥ Ï°∞Ìöå Ïã§Ìå®: {e}")
            return []
    
    def get_champion_mastery(self, summoner_id: str, count: int = 10) -> List[Dict]:
        """Ï±îÌîºÏñ∏ ÎßàÏä§ÌÑ∞Î¶¨ Ï†ïÎ≥¥ Ï°∞Ìöå"""
        url = f"{self.base_urls['kr']}/lol/champion-mastery/v4/champion-masteries/by-summoner/{summoner_id}"
        headers = {'X-Riot-Token': self.api_key}
        
        try:
            response = requests.get(url, headers=headers, timeout=10)
            if response.status_code == 200:
                data = response.json()
                return data[:count]
            else:
                return []
        except Exception as e:
            print(f"‚ùå Ï±îÌîºÏñ∏ ÎßàÏä§ÌÑ∞Î¶¨ Ï°∞Ìöå Ïã§Ìå®: {e}")
            return []
    
    def get_player_full_info(self, game_name: str, tag_line: str) -> Optional[Dict]:
        """ÌîåÎ†àÏù¥Ïñ¥Ïùò Ï†ÑÏ≤¥ Ï†ïÎ≥¥ Ï°∞Ìöå"""
        try:
            account_info = self.get_summoner_by_riot_id(game_name, tag_line)
            if not account_info:
                return None
            
            puuid = account_info['puuid']
            summoner_info = self.get_summoner_by_puuid(puuid)
            if not summoner_info:
                return None
            
            summoner_id = summoner_info['id']
            league_entries = self.get_league_entries(summoner_id)
            champion_masteries = self.get_champion_mastery(summoner_id, 5)
            
            player_info = {
                'puuid': puuid,
                'summoner_id': summoner_id,
                'game_name': game_name,
                'tag_line': tag_line,
                'summoner_level': summoner_info.get('summonerLevel', 0),
                'profile_icon_id': summoner_info.get('profileIconId', 0),
                'league': league_entries[0] if league_entries else None,
                'champion_masteries': champion_masteries,
                'last_updated': datetime.now().isoformat()
            }
            
            return player_info
            
        except Exception as e:
            print(f"‚ùå ÌîåÎ†àÏù¥Ïñ¥ Ï†ïÎ≥¥ Ï°∞Ìöå Ïã§Ìå®: {e}")
            return None

# ===== ÎÇ¥Ï†Ñ Í¥ÄÎ¶¨ ÏãúÏä§ÌÖú ÌÅ¥ÎûòÏä§ =====

class MatchManager:
    def __init__(self, riot_api: RiotAPIManager):
        self.riot_api = riot_api
        self.matches = []
        self.players = {}
    
    def add_player(self, game_name: str, tag_line: str) -> Optional[Dict]:
        """ÌîåÎ†àÏù¥Ïñ¥ Ï∂îÍ∞Ä"""
        player_key = f"{game_name}#{tag_line}"
        
        if player_key in self.players:
            print(f"‚úÖ ÌîåÎ†àÏù¥Ïñ¥ Ï†ïÎ≥¥ Ï∫êÏãúÏóêÏÑú Î°úÎìú: {player_key}")
            return self.players[player_key]
        
        print(f"üîç ÌîåÎ†àÏù¥Ïñ¥ Ï†ïÎ≥¥ Ï°∞Ìöå Ï§ë: {player_key}")
        player_info = self.riot_api.get_player_full_info(game_name, tag_line)
        
        if player_info:
            self.players[player_key] = player_info
            print(f"‚úÖ ÌîåÎ†àÏù¥Ïñ¥ Ï∂îÍ∞Ä ÏôÑÎ£å: {player_key}")
            return player_info
        else:
            print(f"‚ùå ÌîåÎ†àÏù¥Ïñ¥ Ï∂îÍ∞Ä Ïã§Ìå®: {player_key}")
            return None
    
    def create_match(self, match_id: str, match_type: str, host: str, players: List[str]) -> Dict:
        """ÎÇ¥Ï†Ñ ÏÉùÏÑ±"""
        match_data = {
            'id': match_id,
            'type': match_type,
            'host': host,
            'players': [],
            'status': 'open',
            'created_at': datetime.now().isoformat(),
            'blue_team': [],
            'red_team': [],
            'bans': [],
            'picks': []
        }
        
        for player in players:
            if '#' in player:
                game_name, tag_line = player.split('#', 1)
                player_info = self.add_player(game_name, tag_line)
                if player_info:
                    match_data['players'].append(player_info)
        
        self.matches.append(match_data)
        print(f"‚úÖ ÎÇ¥Ï†Ñ ÏÉùÏÑ± ÏôÑÎ£å: {match_id} ({len(match_data['players'])}Î™Ö Ï∞∏Í∞Ä)")
        return match_data
    
    def analyze_team_balance(self, match_id: str) -> Dict:
        """ÌåÄ Î∞∏Îü∞Ïä§ Î∂ÑÏÑù"""
        match = self.get_match(match_id)
        if not match:
            return {}
        
        tier_scores = {
            'IRON': 1, 'BRONZE': 2, 'SILVER': 3, 'GOLD': 4,
            'PLATINUM': 5, 'DIAMOND': 6, 'MASTER': 7, 'GRANDMASTER': 8, 'CHALLENGER': 9
        }
        rank_scores = {'IV': 0.25, 'III': 0.5, 'II': 0.75, 'I': 1.0}
        
        def calculate_player_score(player):
            if not player.get('league'):
                return 0
            
            league = player['league']
            tier = league.get('tier', 'IRON')
            rank = league.get('rank', 'IV')
            lp = league.get('leaguePoints', 0)
            
            base_score = tier_scores.get(tier, 1)
            rank_multiplier = rank_scores.get(rank, 0.5)
            lp_bonus = lp / 1000
            
            return base_score + rank_multiplier + lp_bonus
        
        player_scores = [calculate_player_score(player) for player in match['players']]
        sorted_players = sorted(zip(match['players'], player_scores), key=lambda x: x[1], reverse=True)
        
        blue_team = []
        red_team = []
        
        for i, (player, score) in enumerate(sorted_players):
            if i % 2 == 0:
                blue_team.append((player, score))
            else:
                red_team.append((player, score))
        
        blue_score = sum(score for _, score in blue_team)
        red_score = sum(score for _, score in red_team)
        
        balance_analysis = {
            'blue_team': blue_team,
            'red_team': red_team,
            'blue_score': blue_score,
            'red_score': red_score,
            'balance_ratio': min(blue_score, red_score) / max(blue_score, red_score) if max(blue_score, red_score) > 0 else 0,
            'is_balanced': abs(blue_score - red_score) < 1.0
        }
        
        return balance_analysis
    
    def get_match(self, match_id: str) -> Optional[Dict]:
        """ÎÇ¥Ï†Ñ Ï°∞Ìöå"""
        for match in self.matches:
            if match['id'] == match_id:
                return match
        return None

# ===== ÏãúÍ∞ÅÌôî ÌÅ¥ÎûòÏä§ =====

class MatchVisualizer:
    def __init__(self, match_manager: MatchManager):
        self.match_manager = match_manager
    
    def plot_tier_distribution(self, figsize=(12, 8)):
        """Ìã∞Ïñ¥ Î∂ÑÌè¨ ÏãúÍ∞ÅÌôî"""
        tier_dist = {}
        for player in self.match_manager.players.values():
            if player.get('league'):
                tier = player['league'].get('tier', 'UNRANKED')
                tier_dist[tier] = tier_dist.get(tier, 0) + 1
        
        if not tier_dist:
            print("‚ùå Ìã∞Ïñ¥ Î∂ÑÌè¨ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.")
            return
        
        tier_order = ['IRON', 'BRONZE', 'SILVER', 'GOLD', 'PLATINUM', 'DIAMOND', 'MASTER', 'GRANDMASTER', 'CHALLENGER']
        ordered_tiers = {tier: tier_dist.get(tier, 0) for tier in tier_order if tier in tier_dist}
        
        plt.figure(figsize=figsize)
        bars = plt.bar(ordered_tiers.keys(), ordered_tiers.values(), 
                      color=['#8B4513', '#CD7F32', '#C0C0C0', '#FFD700', '#00CED1', '#9932CC', '#FF69B4', '#FF4500', '#FF0000'])
        
        plt.title('ÌîåÎ†àÏù¥Ïñ¥ Ìã∞Ïñ¥ Î∂ÑÌè¨', fontsize=16, fontweight='bold')
        plt.xlabel('Ìã∞Ïñ¥', fontsize=12)
        plt.ylabel('ÌîåÎ†àÏù¥Ïñ¥ Ïàò', fontsize=12)
        plt.xticks(rotation=45)
        
        for bar in bars:
            height = bar.get_height()
            plt.text(bar.get_x() + bar.get_width()/2., height + 0.1,
                    f'{int(height)}', ha='center', va='bottom')
        
        plt.tight_layout()
        plt.show()
    
    def plot_team_balance(self, match_id: str, figsize=(12, 6)):
        """ÌåÄ Î∞∏Îü∞Ïä§ ÏãúÍ∞ÅÌôî"""
        balance = self.match_manager.analyze_team_balance(match_id)
        
        if not balance:
            print("‚ùå ÌåÄ Î∞∏Îü∞Ïä§ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.")
            return
        
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=figsize)
        
        teams = ['Î∏îÎ£®ÌåÄ', 'Î†àÎìúÌåÄ']
        scores = [balance['blue_score'], balance['red_score']]
        colors = ['#1f77b4', '#ff7f0e']
        
        bars = ax1.bar(teams, scores, color=colors)
        ax1.set_title('ÌåÄ Î∞∏Îü∞Ïä§ Ï†êÏàò', fontsize=14, fontweight='bold')
        ax1.set_ylabel('Ï†êÏàò', fontsize=12)
        
        for bar in bars:
            height = bar.get_height()
            ax1.text(bar.get_x() + bar.get_width()/2., height + 0.1,
                    f'{height:.2f}', ha='center', va='bottom')
        
        balance_ratio = balance['balance_ratio']
        ax2.pie([balance_ratio, 1-balance_ratio], 
                labels=['Î∞∏Îü∞Ïä§', 'Î∂àÍ∑†Ìòï'], 
                colors=['#2ecc71', '#e74c3c'],
                autopct='%1.1f%%')
        ax2.set_title(f'Î∞∏Îü∞Ïä§ ÎπÑÏú®: {balance_ratio:.2f}', fontsize=14, fontweight='bold')
        
        plt.tight_layout()
        plt.show()

# ===== ÏÇ¨Ïö© ÏòàÏãú =====

def demo_usage():
    """Îç∞Î™® ÏÇ¨Ïö© ÏòàÏãú"""
    print("üéÆ ÎùºÏù¥Ïóá API ÎÇ¥Ï†Ñ Í¥ÄÎ¶¨ ÏãúÏä§ÌÖú Îç∞Î™®")
    print("="*50)
    
    # API ÌÇ§ ÏûÖÎ†• (Ïã§Ï†ú ÏÇ¨Ïö© ÏãúÏóêÎäî ÌôòÍ≤ΩÎ≥ÄÏàò ÏÇ¨Ïö©)
    api_key = input("ÎùºÏù¥Ïóá API ÌÇ§Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî: ").strip()
    
    if not api_key:
        print("‚ùå API ÌÇ§Í∞Ä ÌïÑÏöîÌï©ÎãàÎã§.")
        return
    
    # ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî
    riot_api = RiotAPIManager(api_key)
    match_manager = MatchManager(riot_api)
    visualizer = MatchVisualizer(match_manager)
    
    print("\n‚úÖ ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî ÏôÑÎ£å!")
    
    # Îç∞Î™® ÌîåÎ†àÏù¥Ïñ¥ Ï∂îÍ∞Ä
    print("\nüë§ Îç∞Î™® ÌîåÎ†àÏù¥Ïñ¥ Ï∂îÍ∞Ä Ï§ë...")
    demo_players = [
        "Hide on bush#KR1",  # Ïã§Ï†ú ÌîåÎ†àÏù¥Ïñ¥ IDÎ°ú Î≥ÄÍ≤Ω
        "Faker#KR1",
        "T1 Keria#KR1"
    ]
    
    for player in demo_players:
        if '#' in player:
            game_name, tag_line = player.split('#', 1)
            match_manager.add_player(game_name, tag_line)
    
    # Îç∞Î™® ÎÇ¥Ï†Ñ ÏÉùÏÑ±
    print("\nüèÜ Îç∞Î™® ÎÇ¥Ï†Ñ ÏÉùÏÑ± Ï§ë...")
    match = match_manager.create_match(
        "Îç∞Î™®ÎÇ¥Ï†Ñ001", 
        "soft", 
        "Í¥ÄÎ¶¨Ïûê", 
        demo_players
    )
    
    # ÌåÄ Î∞∏Îü∞Ïä§ Î∂ÑÏÑù
    print("\n‚öñÔ∏è ÌåÄ Î∞∏Îü∞Ïä§ Î∂ÑÏÑù Ï§ë...")
    balance = match_manager.analyze_team_balance("Îç∞Î™®ÎÇ¥Ï†Ñ001")
    if balance:
        print(f"Î∏îÎ£®ÌåÄ Ï†êÏàò: {balance['blue_score']:.2f}")
        print(f"Î†àÎìúÌåÄ Ï†êÏàò: {balance['red_score']:.2f}")
        print(f"Î∞∏Îü∞Ïä§ ÎπÑÏú®: {balance['balance_ratio']:.2f}")
        
        # ÏãúÍ∞ÅÌôî
        visualizer.plot_team_balance("Îç∞Î™®ÎÇ¥Ï†Ñ001")
    
    # Ìã∞Ïñ¥ Î∂ÑÌè¨ ÏãúÍ∞ÅÌôî
    print("\nüìä Ìã∞Ïñ¥ Î∂ÑÌè¨ ÏãúÍ∞ÅÌôî Ï§ë...")
    visualizer.plot_tier_distribution()
    
    print("\n‚úÖ Îç∞Î™® ÏôÑÎ£å!")

# Ïã§Ìñâ
if __name__ == "__main__":
    demo_usage()

print("‚úÖ ÏΩîÎû©Ïö© ÎùºÏù¥Ïóá API ÎÇ¥Ï†Ñ Í¥ÄÎ¶¨ ÏãúÏä§ÌÖú Ï§ÄÎπÑ ÏôÑÎ£å!")
print("\nüöÄ ÏÇ¨Ïö© Î∞©Î≤ï:")
print("1. ÏúÑÏùò ÏΩîÎìúÎ•º ÏΩîÎû©ÏóêÏÑú Ïã§ÌñâÌïòÏÑ∏Ïöî")
print("2. ÎùºÏù¥Ïóá API ÌÇ§Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî")
print("3. Îç∞Î™®Í∞Ä ÏûêÎèôÏúºÎ°ú Ïã§ÌñâÎê©ÎãàÎã§")
print("\nüí° Ïã§Ï†ú ÏÇ¨Ïö© ÏãúÏóêÎäî demo_usage() Ìï®ÏàòÎ•º ÏàòÏ†ïÌïòÏó¨ ÏõêÌïòÎäî Í∏∞Îä•ÏùÑ ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî!")
